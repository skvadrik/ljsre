%{

#include <stddef.h> // NULL

#include "ast.h"
#include "debug_parser.h"
#include "parser.h"

bool Parser::parse (TokenArray & tok_arr, slab_allocator<> & allocator)
{
    void * semantics = NULL;

#   define LALR2C_R_TOKEN_TYPE             tok_arr.start[tok_arr.index].type
#   define LALR2C_R_TOKEN_SEMANTICS        tok_arr.start[tok_arr.index].value

#   define LALR2C_RW_STACK_STATE(n)        (stack_top - n)->state
#   define LALR2C_RW_STACK_SEMANTICS(n)    (stack_top - n)->semantics

#   define LALR2C_E_SHIFT_TOKEN()          do { ++ tok_arr.index; } while (0)
#   define LALR2C_E_RESERVE_STACK()        do { ++ stack_top; } while (0)
#   define LALR2C_E_POP_STACK(n)           do { stack_top -= n; } while (0)

#   define LALR2C_RW_TMP_SEMANTICS         semantics

#   define LALR2C_RW_IS_1ST_CALL           is_start

%}

%token    T_ALT
%token    T_ASSERT
%token    T_ASSERT_FOLLOW
%token    T_ASSERT_FOLLOW_NOT
%token    T_BACKREF
%token    T_CLASS
%token    T_CLASS_END
%token    T_CLASS_START
%token    T_CLASS_UNBOXED
%token    T_CLASS_START_NEG
%token    T_COUNTED_REPEAT
%token    T_DASH
%token    T_DOT
%token    T_LBRACE_CAPTURE
%token    T_LBRACE_FOLLOW
%token    T_LBRACE_FOLLOW_NOT
%token    T_LBRACE_LAZY
%token    T_ONE_MANY
%token    T_RBRACE
%token    T_RUNE
%token    T_RUNE_UNBOXED
%token    T_TIMES
%token    T_TIMES_FROM
%token    T_TIMES_FROM_TO
%token    T_ZERO_MANY
%token    T_ZERO_ONE

%fail        { return false; }

%start       pattern
%stop        T_LAMBDA

%%

class_ranges
: {
    $$ = allocator.allocate_type<array<Rune, slab_allocator<> > > ();
    new ($$) array<Rune, slab_allocator<> > (allocator);
}
| class_ranges T_RUNE_UNBOXED {
    const Rune r = * static_cast<Rune *> ($2);
    static_cast<array<Rune, slab_allocator<> > *> ($1)->push_back (r);
}
| class_ranges T_CLASS_UNBOXED {
    const array<Rune, slab_allocator<> > & range = * static_cast<const array<Rune, slab_allocator<> > *> ($2);
    for (unsigned int i = 0; i < range.size (); ++i)
        static_cast<array<Rune, slab_allocator<> > *> ($1)->push_back (range[i]);
}
| class_ranges T_RUNE_UNBOXED T_DASH T_RUNE_UNBOXED {
    const Rune r1 = * static_cast<Rune *> ($2);
    const Rune r2 = * static_cast<Rune *> ($4);
    const Rune r = r2 << 16 | r1;
    static_cast<array<Rune, slab_allocator<> > *> ($1)->push_back (r);
}
;

class
: T_CLASS_START class_ranges T_CLASS_END {
    static_cast<REClass *> ($1)->runes = static_cast<array<Rune, slab_allocator<> > *> ($2);
}
| T_CLASS_START T_DASH class_ranges T_CLASS_END {
    const Rune r = '-';
    static_cast<array<Rune, slab_allocator<> > *> ($3)->push_back (r);
    static_cast<REClass *> ($1)->runes = static_cast<array<Rune, slab_allocator<> > *> ($3);
}
| T_CLASS_START class_ranges T_DASH T_CLASS_END {
    const Rune r = '-';
    static_cast<array<Rune, slab_allocator<> > *> ($2)->push_back (r);
    static_cast<REClass *> ($1)->runes = static_cast<array<Rune, slab_allocator<> > *> ($2);
}
| T_CLASS_START T_DASH class_ranges T_DASH T_CLASS_END {
    const Rune r = '-';
    static_cast<array<Rune, slab_allocator<> > *> ($3)->push_back (r);
    static_cast<REClass *> ($1)->runes = static_cast<array<Rune, slab_allocator<> > *> ($3);
}
;

atom
: T_RUNE    /* empty */
| T_BACKREF    /* empty */
| T_DOT    /* empty */
| class    /* empty */
| T_CLASS    /* empty */
| T_LBRACE_CAPTURE disjunction T_RBRACE {
    $$ = allocator.allocate_type<RECapture> ();
    new ($$) RECapture ($2, true);
}
| T_LBRACE_LAZY disjunction T_RBRACE {
    $$ = allocator.allocate_type<RECapture> ();
    new ($$) RECapture ($2, false);
}
;

assertion
: T_ASSERT    /* empty */
| T_LBRACE_FOLLOW disjunction T_RBRACE {
    $$ = allocator.allocate_type<REAssertFollow> ();
    new ($$) REAssertFollow ($2, false);
}
| T_LBRACE_FOLLOW_NOT disjunction T_RBRACE {
    $$ = allocator.allocate_type<REAssertFollow> ();
    new ($$) REAssertFollow ($2, true);
}
;

term
: assertion    /* empty */
| atom    /* empty */

/* "e*|e*?" */
| atom T_ZERO_MANY {
    $$ = allocator.allocate_type<REZeroMany> ();
    new ($$) REZeroMany ($1, true);
}
| atom T_ZERO_MANY T_ZERO_ONE {
    $$ = allocator.allocate_type<REZeroMany> ();
    new ($$) REZeroMany ($1, false);
}

/* "e+"/"e+?" */
| atom T_ONE_MANY {
    $$ = allocator.allocate_type<REOneMany> ();
    new ($$) REOneMany ($1, true);
}
| atom T_ONE_MANY T_ZERO_ONE {
    $$ = allocator.allocate_type<REOneMany> ();
    new ($$) REOneMany ($1, false);
}

/* "e?"/"e??" */
| atom T_ZERO_ONE {
    $$ = allocator.allocate_type<REZeroOne> ();
    new ($$) REZeroOne ($1, true);
}
| atom T_ZERO_ONE T_ZERO_ONE {
    $$ = allocator.allocate_type<REZeroOne> ();
    new ($$) REZeroOne ($1, false);
}

/* "e{n}"/"e{n}?" */
| atom T_TIMES {
    $$ = allocator.allocate_type<RETimes> ();
    new ($$) RETimes ($1, * (static_cast<unsigned int *> ($2)), true);
}
| atom T_TIMES T_ZERO_ONE {
    $$ = allocator.allocate_type<RETimes> ();
    new ($$) RETimes ($1, * (static_cast<unsigned int *> ($2)), false);
}

/* "e{n,}"/"e{n,}?" */
| atom T_TIMES_FROM {
    $$ = allocator.allocate_type<RETimesFrom> ();
    new ($$) RETimesFrom ($1, * (static_cast<unsigned int *> ($2)), true);
}
| atom T_TIMES_FROM T_ZERO_ONE {
    $$ = allocator.allocate_type<RETimesFrom> ();
    new ($$) RETimesFrom ($1, * (static_cast<unsigned int *> ($2)), false);
}

/* "e{n,m}"/"e{n,m}?" */
| atom T_TIMES_FROM_TO {
    $$ = allocator.allocate_type<RETimesFromTo> ();
    unsigned int * p = static_cast<unsigned int *> ($2);
    new ($$) RETimesFromTo ($1, p[0], p[1], true);
}
| atom T_TIMES_FROM_TO T_ZERO_ONE {
    $$ = allocator.allocate_type<RETimesFromTo> ();
    unsigned int * p = static_cast<unsigned int *> ($2);
    new ($$) RETimesFromTo ($1, p[0], p[1], false);
}
;

alternative
: term    /* empty */
| alternative term {
    $$ = allocator.allocate_type<RECat> ();
    new ($$) RECat ($1, $2);
}
;

disjunction
: /* empty */ {
    $$ = allocator.allocate_type<REEmpty> ();
    new ($$) REEmpty ();
}
| alternative    /* empty */
| alternative T_ALT disjunction {
    $$ = allocator.allocate_type<REAlt> ();
    new ($$) REAlt ($1, $3);
}
| T_ALT disjunction {
    REEmpty * p = allocator.allocate_type<REEmpty> ();
    new (p) REEmpty ();
    $$ = allocator.allocate_type<REAlt> (); new ($$) REAlt (p, $2);
}
;

pattern : disjunction;


%{

    return true;

#   undef LALR2C_R_TOKEN_TYPE
#   undef LALR2C_R_TOKEN_SEMANTICS

#   undef LALR2C_RW_STACK_STATE
#   undef LALR2C_RW_STACK_SEMANTICS

#   undef LALR2C_E_SHIFT_TOKEN
#   undef LALR2C_E_RESERVE_STACK
#   undef LALR2C_E_POP_STACK

#   undef LALR2C_RW_TMP_SEMANTICS

#   undef LALR2C_RW_IS_1ST_CALL

}

%}
